---
   layout: post
   title: "JAVA摘要"                                                        
   date: 2020-04-29 09:00:00 +0530
   categories: Java
---
  Java


# JAVA摘要

* JVM  java核心    跨平台
* JRE    运行类库   + JVM   运行环境
* JDK  编辑器等开发工具 + JRE 
* 源代码.java-----编译器(javac)-----.class字节码文件----->jvm运行

## 关键字特点

* 纯小写纯英文
* String不是关键字

## 标识符

* 英文,数字,下划线,$
* 不以数字开头
* 不能使用关键字

### 类名规范

* 首字母大写 大驼峰式

### 变量名和方法名规范

* 首字母小写,后面每个首字母大写, 小驼峰式

## 常量

* 字符串常量 ""也是字符常量   0个 1个 多个
* 整数常量
* 浮点数常量
* 字符常量(一个字符),中文也有 '中'   注意单引号不可以为''      有且仅一个字符
* 布尔常量 true  false
* 空常量 null   不能直接打印和输出  System.out.println(null)   错误写法

## 数据类型

### 基本数据类型

* 整数型      byte   short    int   long
* 浮点型      float  double
* 字符型      char
* 布尔型      boolean

### 内存占用

*  º ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹

| 数据类型     | 关键字       | 内存占用(字节) | 取值范围                |
| ------------ | ------------ | -------------- | ----------------------- |
| 字符型       | byte         | 1              | -2⁷ ~ 2⁷-1              |
| 短整型       | short        | 2              | -2¹⁵ ~ 2¹⁵-1   (-32768) |
| 整型         | int(默认)    | 4              | -2³¹ ~ 2³¹-1  21亿左右  |
| 长整型       | long         | 8              | -2⁶³ ~ 2⁶³-1            |
| 单精度浮点数 | float        | 4              | 1.4013E-45 ~ 3.4028E+38 |
| 双精度浮点数 | double(默认) | 8              | 4.9E-324 ~ 1.7977E+308  |
| 字符串       | char         | 2              | 0 ~ 2¹⁵-1   (65535)     |
| 布尔类型     | boolean      | 1              | true  false             |

* 字符串为引用类型
* 浮点型不是精确值  而是近视值
* 数据范围与字节数无关  ---->科学计数法省空间
* float后缀f    0.5f
* long后缀L    100L

### 注意事项

* 变量调用前必须先赋值
* 变量赋值不要超过范围
* 注意整型默认为int,浮点型默认为double
* 注意float和long的后缀不要丢
* 注意变量的作用域
  * 块级作用域
  * 方法内
* 一条语句多变量 不推荐
  * `int a,b,c;`
  * `int x=1,y=2,z=3;`

## 类型转换

* `long num1 = 100;`       数据类型不一样   自动类型转换
* `double num2 = 2.5f;`   数据类型不一样   自动类型转换
* `float num3 = 30L`    float范围大     数据类型不一样   自动类型转换
* 
* `int num =100L`      不兼容类型  错误
  * `int num = (int)100L;`
* `int num = (int)6000000000L;`      右边超int范围   溢出
  * 注意编译运行通过 不报错    但数值不正确
* `int num = (int)3.5;`          精度损失    //3    不是四舍五入
* `int num = (int)3.99;`       //3

### 自动类型转换(式)

* 特点: 代码不需要进行特殊处理,自动完成
* 规则: 数据范围从小到大

### 强制类型转换(显示)

* 特点: 代码需要进行特殊的格式处理, 不能自动完成
* 格式: 范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据

### 注意事项

* 强制不推荐使用   可能发生精度损失 或数据溢出

* byte/shor/char 这三种类型都可以进行数学运算 如:+

* ```
  char zifu1 = 'A';
  System.out.println(zifu1 + 1);//66
  
  char类型进行数学运算 会进行一定规则的运算
  
  ```

* byte/shor/char 在进行运算时首先都会被提升为int类型

* ```
  byte num4 = 40;
  byte num5 = 50;
  
  //byte + byte --> int + int --->int
  byte result1 = num4 + num5;   //类型不兼容 报错
   
  	
  short num6 = 60;
  //byte + short --> int + int --->int
  short result2 = num4 + num6;  //类型不兼容 报错
  ```

* 布尔类型不能发生类型转换

* `计算机底层都为二进制`

* ASCII码表

* Unicode码表  0-127部分和ASCII表一样  128 开始出现更多字符

## 运算符

* 运算的结果为数据类型范围较大的那一个

* `+`可以做字符串连接,任何类型与字符串连接结果都为字符串

* 优先级问题

* ```
  System.out.println("aaa"+20+30);//aaa2030
  ```


### +号用法

* 数值为加法
* char类型  计算前会自动提升为int类型
* String类型 连接

### 自增自减注意

* 常量不可以自增,自减

### 赋值注意

* 只有变量才可以进行赋值

* 复合赋值运算符其中隐含了一个强制类型转换

* ```
  byte num = 30;
  //num = num +5;
  //num = byte + int;
  //num = int + int;
  //num = int
  //num = (byte)int
  num +=5;
  System.out.println(num);//35
  ```

### 逻辑运算符

* 逻辑运算符只能用于boolean值
* 可以使用多个逻辑运算符   A && B && C

* && 和 || 的短路效果
* 如果左边判断得到最终结果,那么右边的代码不在执行

### 三元运算符

* 注意赋值时数据类型转换是否符合规则

## 方法

* 若干语句的功能集合   有参数 和 返回值

* 方法的定义不可以嵌套
* 方法的定义先后顺序无所谓
* 方法有返回值但可以单独调用   不需要吧返回值赋值给一个变量  也是可以的
* 返回值类型为void的只能进行单独调用 不能进行打印调用和赋值调用
* 返回类型为void的可以写renturn;   只是结束而已 但不能加东西
* return可以有多可但执行只能有一个

### Jshell使用(j9新特性)

* 轻量级工具
* 只适用于完成一些简单的代码

* `/exit` 退出

### 编译器的优化

#### 隐含强转

* 对于byte/short/char 三种类型来说 如果右侧赋值的数值没有超过范围

* 右侧没有超过范围, 编译器会补上强转(隐含)

* int --> byte

* ```
  byte num1 = 30;
  ```

* 右侧超过范围直接报错

* ```
  byte num1 = 128;
  ```

* int  --- > char

* 右侧没有超过范围, 编译器会补上强转(隐含)

* ```
  char zifu = 65;
  ```


#### 常量优化

* 在变量进行赋值的时候 右侧表达式都是常量,没有任何变量时

* 编译器会直接将若干个常量表达式计算得到的结果赋值给左边(编译的时候就处理了 而不是在运行的时候)

* 注意不能超数据范围

* ```
  short a = 5;
  short a = 8;
  short result = a + b;//报错 进度损失   short  ---> int + int
  ```

* ```
  short result = 5 + 8;
  //编译器自动处理  short result = 13;  //编译的时候就处理了
  ```

## 流程控制

### switch注意事项

* 多个case的值不可以重复
* switch后面的括号只能下列数据类型
  * `byte/short/char/int`
  * `String/enum`
* switch里的`语句顺序可以颠倒`
* break语句不使用时的`穿透性`

### 循环控制

* do~while注意有分号

* ```
  do{
      循环体
  }while(条件判断);//注意有分号
  ```

* do~while至少执行一次

* 次数确定用for  否则用while

### 方法的重载(overload)

* 参数的个数不同
* 参数的类型不同
* 参数的多类型顺序不同

## 数组

* 引用类型
* 内存对应的是哈希值
* 数组长度不可变

### 动态初始化

* 指定初始化

* ```
  int[] arr = new int[3];
  ```

* 可以拆分

* ```
  int[] arr;
  arr = new int[3];
  ```

* 默认值

* ```
  整型       0
  浮点型     0.0
  字符型     '\u0000'
  布尔类型    false
  引用类型    null
  ```

### 静态初始化

* 指定内容

* 静态初始化也是默认值的过程,只不过马上替换为{}里的值了

* 长度自动推算

* ```
  int[] arr = new int[]{5, 15, 25};
  ```

* 可以拆分

* ```
  int[] arr;
  arr = new int[]{5,15,25};
  ```

#### 省略格式

```
int[] arr = {5, 15, 25};
```

* 不可以拆分

* ```
  错误
  int[] arr;
  arr = {5, 15, 25};
  ```

### 使用建议

* 确定内容使用静态初始化,否则使用动态初始化

### 常用方法

#### 冒泡排序

```
int[]　arr = {23,12,48,56,45};
int temp = -1;

for(int i=0;i<arr.length;i++) {
	for(int j=i+1;j<arr.length;j++) {
		if(arr[i]>arr[j]) {
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
}

	//开始                     
	23 12 48 56 45
	//第1遍后 				 	i = 0
	12 23 48 56 45
	//第2遍后					i = 1
	12 23 48 56 45	
	//第3遍后					i = 2
	12 23 45 56 48
	//第4遍后					i = 3
	12 23 45 48 56	
	//第5遍后					i = 4
	12 23 45 48 56
```

#### 二分查找

```
int[] arr = {45, 34, 53, 43};

int i = Arrays.binarySearch(arr, 34);
```

#### 选择排序

```
	   int[] arr = {23,12,48,56,45};
	
　　　　for(int i=0;i<arr.length;i++) {
            int inedx = i;
            for(int j=i;j<arr.length;j++) {
                if(arr[j] < arr[inedx]) {
                    inedx = j;//记录位置
                }
            }
            //最后做一次交换
            int temp1 = arr[i];
            arr[i] = arr[inedx];
            arr[inedx] = temp1;
        }

	//开始                     
	23 12 48 56 45
	//第1遍后					i = 0
	12 23 48 56 45
	//第2遍后					i = 1
	12 23 48 56 45	
	//第3遍后					i = 2
	12 23 45 56 48
	//第4遍后					i = 3
	12 23 45 48 56	
	//第5遍后					i = 4
	12 23 45 48 56
	
没次记录index的变化
做1次交换
```

### 常见异常

* 数组越界
* 空指针

### 注意事项

* 数组类型作为参数和返回值时, 传递的是地址值

## Java内存

* 5个部分

### 栈内存(Stack)

* 存放的都是方法中的`局部变量`,  `方法的运行一定要在栈内存当中`
* 局部变量: 方法的参数, 或者是方法()内部的变量
* 作用域: 一但超出作用域, 立即从栈内存当中消失

### 堆内存(Heap)

* `凡是new出来的东西, 都在堆当中`
* 堆内存里面的东西都有一个地址值:16进制
* 堆内存里面的数据,都有默认值

### 方法区(Method Area)

* 存储.class相关信息,包含方法的信息

### 本地方法栈(Native Method Stack)

* 与操作系统相关

### 寄存器(pc Register)

* 与CPU相关

## 面向对象

* Array.toString();方法

### 类

* 是一组相关属性和行为的集合,
* 可以看成是一类事物的模板
* 抽象的

#### 属性(成员变量)

* 改事物的状态信息
* 有默认值

#### 行为(成员方法)

* 该事物能做什么
* 不需要static关键字
* 调用时调的是内存值

### 对象

*  对象是类的实例,具备该类事务的属性和方法
* 具体的

### 局部变量和成员变量的区别

| 局部变量                              | 成员变量                                    |
| ------------------------------------- | ------------------------------------------- |
| 定义在方法内部                        | 定义咋方法外部,直接写在类中                 |
| 只有方法当中才可以使用                | 整个类全都可以通用                          |
| 没有默认值,使用时必须赋初始值         | 有默认值                                    |
| 位于栈内存                            | 位于对内存                                  |
| 随着方法进栈而诞生,随着方法出栈而消失 | 随着对象创建而诞生,随着对象被垃圾回收而消失 |

## 封装	

* 具体步骤隐藏,外界不可见
* 方法是一种分装
* 关键字private也是一种分装

### 注意事项

* 对于基本类型当中的boolean值,Getter方法一定要写成isXxx的形式,而setXxx规则不变

## this关键字

* 当方法的局部变量和类的成员变量重名时,就近原则
* 使用this.成员变量访问
* 谁调用,this就是谁

## 构造方法

* 用于创建对象
* 构造方法必须和所在类名称完全相同
* 不要写返回值,连void也没有
* 构造方法不能return一个具体的返回值
* 如果没有编写构造方法, 编译器有一个默认的构造方法
* 一但编写了至少一个构造方法,编译器就不再赠送
* 构造方法可以重载

## 一个标准的类(Java Bean)

* 成员变量都使用private修饰
* 为每一个成员方法编写一对Getter/Setter方法
* 编译一个无参构造方法
* 编译一个全参构造方法

## API

* 应用程序编程接口
* 现成的工具类

## 匿名对象

* 对象只使用一次是使用

## Random

```
Random rm = new Random();
int num = rm.nextInt();//int 的整个范围 有正负

//左闭右开
Random rm = new Random();
int num = rm.nextInt(3);//[0,3)

Random rm = new Random();
int num = rm.nextInt(3)+1;//[1,4)
```

## 对象数组

### ArrayList

* 集合长度可变
* 直接打印不是地址值 而是 内容   java内部处理过

#### 常用方法

* boolean add(E e)    ArrayList的add时一定成功的
* E get(int index)
* E remove(int index)
* int size

### 泛型

* 规定存储指定类型
* 只能写引用类型    基本类型 使用 包装类
* 泛型中存的时地址值

### String

* 字符串常量

* 字符串效果上相当于是char[]字符数组, 但是`底层原理是byte[]`字节数组

* 3+1种创建方式

* ```
  String str1 = new String();//空字符串
  
  //字符数组创建
  char[] charArray = {'A', 'B', 'C'};
  String str2 = new String(charArray);//ABC
  
  //字节数组创建
  byte[] byteArray = {97, 98, 99};
  String str2 = new String(byteArray);//abc
  
  //直接创建
  String str4 = "Hello";
  ```

* 直接创建 也是对象

### 字符串常量池

* 双引号直接写的字符串
* 底层是地址值  保存的是byte的数组 byte[]{97, 98, 99}

```
String str1 = "abc";//在字符串中  
//底层是地址值  保存的是byte的数组 byte[]{97, 98, 99}
String str2 = "abc";

//new 出来的不在常量池中
char[] charArray = {'a', 'b', 'c'};//字符串对象   char{'a', 'b', 'c'}  
//底层也是 byte[]{97, 98, 99}   
String str3 = new String(charArray);

System.out.println(str1 == str2);//true   地址值相同
System.out.println(str1 == str3);//false
System.out.println(str1 == str3);//false
```

### 常用方法

* `boolean equals(Object obj)`

* 常量建议写前面

* ```
  "abc".equals(str)//推荐
  
  str.equals("abc")//不推荐
  
  str.equals(null)//报错
  ```

* equalsIgnoreCase();;忽略英文大小写

* 

* `int length();`

* `String concat(String str) ` 拼接两个字符串

* `char charAt(int index)`获取指定索引位置的字符串

* `int indexOf(String str) ` 查找参数字符串首次出现的索引位置  如果没有返回-1

* 

* `Strng substring(int index)`获取从参数位置一直到字符末尾,返回新字符串

* `Strng substring(int begin, int end)`获取从参数从begin开始位置一直到end结束,返回新字符串  左闭右开[begin,end)

* 

* char[] toCharArray()   拆分字符串为字符数组返回

* byte[] getBytes()   获取当前字符串底层的byte数组

* String replace(CharSequence oldString, CharSequence newString)

  * 将所有出现的老字符串替换为新字符串 返回替换后的字符串
  * CharSequence 表示可以接收字符串类型

* 
* String[] split(String regex)  按照参数的规则切割字符串
  * regex 正则表达式
  * 特殊字符要 `\\.`

## 静态static关键字

* 多个对象共享同一份数据
* 属于类
* 可以通过对象调用但不推荐
* 本类中调用可以省略类名.
* 静态只能访问静态, 非静态可以访问非静态也可以访问静态
  * 应为内存中先有静态,再有非静态
* 静态方法中不能使用this关键字
* 类名称访问静态 只和类有关系 和对象没有关系
* 在方法区的静态区

### 静态代码块

```
static{
    
}
```

* 当第一次用到本类时, 静态代码块`执行唯一的一次`
* 用途  用于一次性的对静态成员变量进行赋值

## Arrays

* static String toString(数组)   [元素1, 元素2, 元素3 ]
  * Arrays.toString();
* static void sort(数组)   
  * 数字 从小到大升序
  * 字母 从小到大升序
  * 自定义类 需要有自定义的Comparable或者Comparator接口的支持

## Math

* staic double abs(double num)   获取绝对值
* static double ceil(double num) 向上取整
* static double floor(double num) 向下取整
* static long round(double num) 四舍五入
* Math.abs()
* Math.PI 常量

## 继承

* 重写的方法  返回值类型必须 `小于等于` 父类方法对的返回值范围    即父类是Object  子类可以是String
* 子类方法的权限必须 `大于等于`父类方法的权限修饰符

* 子类构造方法第一句 有默认super();     所以子类构造会先调用父类的构造方法
* 父类如果重载l有参构造  则不再赠送   需要手动添加 super(参数);
* this(参数)   在构造方法中调用其他构造方法

### 特点

* 单继承
* 多级继承

## 抽象

* abstract
* public abstract void eat();
* 不能实例化 但是有构造方法  同样子类有super

## 接口

* 一种公共的规范标准

* 引用数据类型

* ```
  public interface 接口名称{
  	//J7
      //常量
      //抽象方法
      //J8
      //默认方法
      //静态方法
      //J9
      //私有方法
  }
  ```

* 接口中的方法都是抽象的  且可以省略 public abstract

* ```
  public class 实现类名称 implements 接口名称{
      //实现接口的所有方法
      //没有完全实现  必须声明为抽象的
  }
  ```

* 接口没有对象

* 默认方法

* ```
  public default 返回值类型 方法名(参数列表){
      //可以解决接口的升级问题     在接口中心添加方法   不用全部改动实现类
  }
  
  //使用    会被继承
  实现类对象.接口默认方法名();
  
  
  //也可以被实现类 重写默认方法
  ```

* 静态方法

* ```
  public static 返回值类型 方法名称(参数列表){
      方法体
  }
  
  使用接口类名直接调用
  接口名称.静态方法();
  ```

* 私有方法

* ```
  //普通私有方法    解决多个普通方法中重复代码的问题
  private 返回值类型 方法名称(参数列表) {
      方法体
  }
  //静态私有方法    解决多个静态方法中重复代码的问题
  public static 返回值类型 方法名称(参数列表){
      方法体
  }
  ```

* 常量

* ```
  public static final int NUM = 10;
  ```

*   public static final 修饰   可以省略   

* 必须赋值

* 大写

### 接口注意事项

* 结构中没有构造方法
* 没有静态代码块
* 继承多接口时  接口名相同  只用实现一个即可
* 接口默认方法冲突必须覆盖  因为调用的时候不知道是谁的
* 直接父类的方法和接口的方法冲突 则使用父类的方法
* 接口可以继承多个接口
  * 也需注意重复的默认代码  必须进行重写  还得带上default关键字  因为接口中的default不能省略

## 多态

* 父类引用指向子类对象
* 接口引用执行实现对象
* 方法可以重写 成员变量不可以重写
* 对于方法 new 谁调谁 没有向上找
* 对于变量 谁是父 用的谁 没有 在往上找 ,不能够重写(子类变量名相同但不是重写过来的)
* 成员方法 `编译看左边 运行看右边`   父类里没有的方法 子类调不到
* 成员变量 `编译看左边 运行看左边`

### 向上转型

* 父类名称 对象名 = new 子类名称();   //多态
* Animal animal = new Cat();
* 创建子类 当做父类来用  (类似从小到大  自动类型转换)
* 子类特有方法调不到

### 向下转型

* 子类名称 对象名 = (子类名称) 父类对象;
* 将父类对象 还原 为子类对象
* Cat cat = (Cat)animal; //  注意本来就是猫 才可以转

### 如何判断是哪个子类

* 对象 instanceof 类名称     返回值  boolean

## final

* 与abstract互斥

* 修饰类
  * 不能被继承
* 修饰方法
  * 不能被重写
* 修饰局部变量
  * 只能赋值一次
  * 基本类型  数据不可变
  * 引用类型  地址值不可变   对象的内容可变
* 修饰成员变量
  * 成员变量具有默认值    final修饰时必须赋值初始值
    * 使用直接赋值
    * 使用构造方法赋值   所有构造都必须对该变量赋值
    * 二者选其一

## 权限修饰符

|              | public | protected | default | private |
| ------------ | ------ | --------- | ------- | ------- |
| 同一个类     | YES    | YES       | YES     | YES     |
| 同一个包     | YES    | YES       | YES     | NO      |
| 不同包子类   | YES    | YES       | NO      | NO      |
| 不同包非子类 | YES    | NO        | NO      | NO      |

## 内部类

### 成员内部类

* 内用外 随便  
* 外用内 需内部对象

#### 如何 使用

* 间接使用
  * 外部类的方法中,使用内部类   调用时 使用外部类的方法
* 直接使用
  * 外部类名称.内部类名称 对象名  =  new 外部类名称(). new 内部类名称();

#### 内部类重名变量访问

* 内部类变量局部
* this.内部类变量
* 外部类.this.外部类变量

### 局部内部类

* 定义在方法内
* 只属于方法   只能对应方法里使用

#### 修饰符

* 外部类       public / (default)
* 成员内部类    public/ protected / (default) /private
* 局部内部类  什么都不能写  也不是default

#### 局部内部类访问的变量

* 局部内部类 只能访问不变的变量  (final 或不变的量)
* 该变量会被赋值到常量池   防止方法出栈了, 但对象new出来的在堆 调用时变量出栈了

#### 包含匿名内部类

* 只用使用位移一次的类

* ```
  接口名称 对象名 = new 接口名称(){
      //覆盖重写所有抽象方法
  }
  
  {}为局部内部类
  ```


#### 匿名对象

* ```
  new 接口名称(){
      //覆盖重写所有抽象方法
  }.方法();
  
  //只能调用一个方法
  ```

  